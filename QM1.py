# -*- coding: utf-8 -*-
"""QM1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fxzxGSiMIwvcArqQwxGXUtR8OrAYOBJV
"""

import numpy as np
import matplotlib.pylab as plt
from scipy.stats import pearsonr

#1-a)
h = 6.626e-34  # J*s
c = 3.0e8      # m/s)
k = 1.3805e-23   # J/K

λ = np.linspace(1e-9, 3e-6, 1000)  # De 1 nm a 1 µm
λ_nm = λ * 1e9  # Convertir a nanómetros
T = [10000, 8000, 5000, 3000]  # Kelvin

def energy(wavelength, temperature):
    return ((8 * np.pi * h ) / (wavelength ** 3)) * (1 / (np.exp((h * c) / (wavelength * k * temperature)) - 1))

plt.figure(figsize=(10, 6))
plt.title('Densidad de Energía por Unidad de Frecuencia en función de Longitud de Onda')
plt.xlabel('Longitud de Onda (nm)')  # Cambiar la etiqueta del eje x
plt.ylabel('Densidad de Energía (J/m^3)')

for temp in T:
    energy_density = energy(λ, temp)
    plt.plot(λ_nm, energy_density, label=f'{temp} K')

plt.legend()
plt.tight_layout()
plt.grid(True)
plt.show()

#1.b)
peaks = []

for temperature in T:
    energy_vals = energy(λ, temperature)
    peak_idx = np.argmax(energy_vals)
    peak_wave = λ[peak_idx]
    peaks.append(peak_wave)

    print(f'Para una temperatura de {temperature} K, la longitud de onda pico es {peak_wave * 1e9:.2f} nm')

    if peak_wave < 1.0e-11:
        print('Está en la región de Rayos gamma')
    elif peak_wave >= 1.0e-11 and peak_wave < 1.0e-8:
        print('Se encuentra en la región de Rayos X')
    elif peak_wave >= 1.0e-8 and peak_wave < 4.0e-7:
        print('Pertenece a la región de Ultravioleta')
    elif peak_wave >= 4.0e-7 and peak_wave < 7.0e-7:
        print('Caímos en la región Visible')
    elif peak_wave >= 7.0e-7 and peak_wave < 1.0e-3:
        print('Está dentro de la región de Infrarrojo')
    elif peak_wave >= 1.0e-3 and peak_wave < 1.0e-1:
        print('Es parte de la región de Microondas')
    else:
        print('Es una señal de la región de Radio')

    print()

#1.c)
h = 6.626e-34  # J*s
c = 3.0e8      # m/s
k = 1.3805e-23  # J/K

F = np.linspace(1e12, 1e15, 10000)  # en Hz


def densidad_energia_f(f, t):
    return ((8 * np.pi * h * (f**3)) / (c**3)) * (1 / (np.exp((h * f) / (k * t)) - 1))

def wien(f, t):
    return ((8 * np.pi * h * (f**3)) / (c**3)) * (1 / (np.exp((h * f) / (k * t))))

def R_J(f, t):
    return (8 * np.pi * k * t * (f**2)) / (c**3)

plt.figure(figsize=(10, 8))  # Creamos la gráfica

formula = ["Planck", "Wien", "Rayleigh-Jeans"]

plt.plot(F * 1e-12, densidad_energia_f(F, 5000), label=formula[0])
plt.plot(F * 1e-12, wien(F, 5000), label=formula[1])
plt.plot(F * 1e-12, R_J(F, 5000), label=formula[2])

plt.xlabel('Frecuencia (THz)')
plt.ylabel('Densidad de Energía (J/Hz*m³)')
plt.title('Densidad de Energía por Unidad de Frecuencia a 5000K')
plt.xlim(0, 1000)
plt.ylim(0, 0.0000000000000012)
plt.legend()
plt.grid(True)
plt.show()

# Definir las tres curvas que deseas comparar (Planck, Wien y Rayleigh-Jeans)
curva_planck = densidad_energia_f(F, 5000)
curva_wien = wien(F, 5000)
curva_rayleigh = R_J(F, 5000)

# Calcular los errores cuadráticos medios (MSE) para las dos comparaciones
mse_planck_wien = np.mean((curva_planck - curva_wien)**2)
mse_planck_rayleigh = np.mean((curva_planck - curva_rayleigh)**2)

# Calcular los coeficientes de correlación de Pearson y sus valores p para ambas comparaciones
correlation_planck_wien, p_value_planck_wien = pearsonr(curva_planck, curva_wien)
correlation_planck_rayleigh, p_value_planck_rayleigh = pearsonr(curva_planck, curva_rayleigh)

# Imprimir los resultados
print("Comparación entre curvas de Planck y Wien:")
print(f"Error cuadrático medio (MSE): {mse_planck_wien}")
print(f"Coeficiente de correlación de Pearson: {correlation_planck_wien}")
print(f"Valor p: {p_value_planck_wien}\n")

print("Comparación entre curvas de Planck y Rayleigh-Jeans:")
print(f"Error cuadrático medio (MSE): {mse_planck_rayleigh}")
print(f"Coeficiente de correlación de Pearson: {correlation_planck_rayleigh}")
print(f"Valor p: {p_value_planck_rayleigh}")

#Este código calcula y compara el error cuadrático medio (MSE) y el coeficiente de correlación de Pearson entre las curvas de Planck y Wien, así como entre las curvas de Planck y Rayleigh-Jeans.
#Un MSE bajo y un coeficiente de correlación cercano a 1 indicarán una mayor concordancia.